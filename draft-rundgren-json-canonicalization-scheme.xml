<?xml version="1.0" encoding="us-ascii"?>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>

<rfc category="std" docName="draft-rundgren-json-canonicalization-scheme-05" ipr="trust200902">
  <front>
    <title abbrev="draft-rundgren-json-canonicalization-scheme">
      JSON Canonicalization Scheme (JCS)
    </title>

    <author fullname="Anders Rundgren" initials="A." surname="Rundgren">
      <organization>Independent</organization>
      <address>
        <postal>
          <street></street>
          <code></code>
          <city>Montpellier</city>
          <country>France</country>
        </postal>
        <email>anders.rundgren.net@gmail.com</email>
        <uri>https://www.linkedin.com/in/andersrundgren/</uri>
      </address>
    </author>

    <author fullname="Bret Jordan" initials="B." surname="Jordan">
      <organization>Symantec Corporation</organization>
      <address>
        <postal>
          <street>350 Ellis Street</street>
          <code>CA 94043</code>
          <city>Mountain View</city>
          <country>USA</country>
        </postal>
        <email>bret_jordan@symantec.com</email>
      </address>
    </author>

    <author fullname="Samuel Erdtman" initials="S." surname="Erdtman">
      <organization>Spotify AB</organization>
      <address>
        <postal>
          <street>Birger Jarlsgatan 61, 4tr</street>
          <code>113 56</code>
          <city>Stockholm</city>
          <country>Sweden</country>
        </postal>
        <email>erdtman@spotify.com</email>
      </address>
    </author>

    <date year="2019" />

    <area>Security</area>

    <workgroup></workgroup>

    <keyword>
      JSON, ECMAScript, Signatures, Cryptography, Canonicalization
    </keyword>

    <abstract>
      <t>
        Cryptographic operations like hashing and signing requires that the
        original data does not change during serialization or parsing.
        By applying the rules defined by the JSON Canonicalization Scheme (JCS),
        data provided in JSON <xref target="RFC8259"/> format can be exchanged "as is",
        while still being usable by secure cryptographic operations.
        JCS achieves this by building on the strict serialization formats for JSON primitives
        defined by ECMAScript <xref target="ES6"/>, constraining JSON data
        to the I&nbhy;JSON <xref target="RFC7493"/> subset,
        and through a platform independent property sorting scheme.
      </t>
      <t>
        The intended audiences of this document are JSON tool vendors, as
        well as designers of JSON based cryptographic solutions.
      </t>
    </abstract>
  </front>

  <middle>
    <section anchor="Introduction" title="Introduction">
      <t>
        Cryptographic operations like hashing and signing requires that the
        original data does not change during serialization or parsing.
        One way of accomplishing this is converting the data into
        a format that has a simple and fixed representation like Base64Url <xref target="RFC4648"/>,
        which is how JWS <xref target="RFC7515"/> addressed this issue.
      </t>
      <t>
        Another solution is to create a canonical version of the data,
        similar to what was done for the XML Signature <xref target="XMLDSIG"/> standard.
        The primary advantage with a canonicalizing scheme is that data
        can be kept in its original form. This is the core rationale behind JCS.
        Put another way: by using canonicalization a JSON Object may remain a JSON Object
        even after being signed which simplifies system design, documentation and logging.
      </t>
      <t>
        To avoid "reinventing the wheel", JCS relies on serialization of JSON primitives compatible with
        ECMAScript (aka JavaScript) beginning with version 6 <xref target="ES6"/>,
        hereafter referred to as "ES6".
      </t>
      <t>
        Seasoned XML developers recalling difficulties getting signatures
        to validate (usually due to different interpretations of the quite intricate
        XML canonicalization rules as well as of the equally extensive
        Web Services security standards), may rightfully wonder why JCS
        would not suffer from similar issues. The reasons are twofold:
        <list style="symbols">
          <t>
            The absence of a namespace concept and default values, as well
            as constraining data to the I&nbhy;JSON subset eliminate the need for specific
            parsers for dealing with canonicalization.
          </t>
          <t>
            JCS compatible serialization of JSON primitives is supported by most
            current Web browsers and as well as by Node.js <xref target="NODEJS"/>,
            while the full JCS specification is supported by multiple
            Open Source implementations (see <xref target="open.source"/>).
            See also <xref target="impl.guidelines"/>.
          </t>
        </list>
      </t>
      <t>
        In summary the JCS specification describes how serialization of JSON primitives compliant
        with ES6 combined with a deterministic property sorting scheme can be used for
        creating "Hashable" representations of JSON data intended for consumption by cryptographic methods.
    </t>
      <t>
        JCS is compatible with some existing systems relying on JSON canonicalization
        such as JWK Thumbprint <xref target="RFC7638"/> and Keybase <xref target="KEYBASE"/>. 
      </t>
      <t>
        For potential uses outside of cryptography see <xref target="JSONCOMP"/>.
      </t>
    </section>

    <section anchor="Terminology" title="Terminology">
      <t>
        The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
        NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
        "MAY", and "OPTIONAL" in this document are to be interpreted as
        described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/>
        when, and only when, they appear in all capitals, as shown here.
      </t>
    </section>

    <section anchor="Operation" title="Detailed Operation">
      <t>
        This section describes the different issues related to creating 
        a canonical JSON representation, and how they are addressed by JCS.
      </t>
      <section anchor="json.datacreation" title="Creation of Input Data">
        <t>
          In order to serialize JSON data, one needs data
          that is adapted for JSON serialization.  This is usually achieved by:
        </t><t>
          <list style="symbols">
            <t>
              Parsing previously generated JSON data.
            </t>
            <t>
              Programmatically creating data.
            </t>
          </list>
        </t>
        <t>
          Irrespective of the method used, the data to be serialized MUST be compatible
          both with ES6 and I&nbhy;JSON <xref target="RFC7493"/>, which implies the following:
        </t>
        <t>
          <list style="symbols">
            <t>
              JSON Objects MUST NOT exhibit duplicate property names. 
            </t>
            <t>
              JSON String data MUST be expressible
              as Unicode <xref target="UNICODE"/>.
            </t>
            <t>
              JSON Number data MUST be expressible
              as IEEE-754 <xref target="IEEE754"/> double precision values.
              For applications needing higher precision or longer integers than
              offered by IEEE-754 double precision,
              <xref target="json.bignumbers"/> outlines how
              such requirements can be supported in an interoperable and extensible way.
            </t>
          </list>
        </t>
        <t>
          Note: parsed JSON String data MUST NOT be altered during subsequent serializations.
          For more information see <xref target="string.subtypes"/>.
        </t>
        <t>
          Note: although the Unicode standard offers a possibility combining
          certain characters into one, referred to as "Unicode Normalization"
          (<eref target="https://www.unicode.org/reports/tr15/">https://www.unicode.org/reports/tr15/</eref>),
          such functionality MUST be delegated to the application layer.
        </t>
      </section>
      <section anchor="json.canonicalization" title="Generation of Canonical JSON Data">
        <t>
          The following subsections describe the steps required for creating a canonical
          JSON representation of the data elaborated on in the previous section.
        </t>
        <t>
          <xref target="canonicalize.js"/> shows sample code for an ES6 based canonicalizer,
          matching the JCS specification.
        </t>
        <section anchor="json.whitespace" title="Whitespace">
          <t>
            Whitespace between JSON elements MUST NOT be emitted.
          </t>
        </section>
        <section anchor="json.serialization.data" title="Serialization of Primitive Data Types">
          <t>
            Assume that you parse a JSON object like the following:
          </t>
          <t>
            <figure align="center"><artwork><![CDATA[  {
    "numbers": [333333333.33333329, 1E30, 4.50,
                2e-3, 0.000000000000000000000000001],
    "string": "\u20ac$\u000F\u000aA'\u0042\u0022\u005c\\\"\/",
    "literals": [null, true, false]
  }]]></artwork></figure>
          </t>
          <t>
            If you subsequently serialize the parsed data
            using a serializer compliant with ES6's <spanx style="verb">JSON.stringify()</spanx>,
            the result would (with a line wrap added for display purposes only),
            be rather divergent with respect to representation of data:
          </t>
          <t>
            <figure align="center"><artwork><![CDATA[  {"numbers":[333333333.3333333,1e+30,4.5,0.002,1e-27],"string":
  "EURO$\u000f\nA'B\"\\\\\"/","literals":[null,true,false]}]]></artwork></figure>
          </t>
          <t>
            <list style="empty">
              <t>
                Note: EURO denotes a single Euro character (Unicode: U+20AC),
                <vspace blankLines="0"/>
                which not being ASCII, is currently not displayable in RFCs.
              </t>
            </list> 
          </t>
          <t>
            The reason for the difference between the parsed data and its
            serialized counterpart, is due to a wide tolerance on input data (as defined
            by JSON <xref target="RFC8259"/>), while output data (as defined by ES6),
            has a fixed representation.  As can be seen by the example,
            numbers are subject to rounding as well.
          </t>
          <t>
            The following subsections describe serialization of primitive JSON data types
            according to JCS.  This part is identical to that of ES6.
          </t>
          <section anchor="json.ser.literals" title="Serialization of Literals">
            <t>
              The JSON literals <spanx style="verb">null</spanx>, <spanx style="verb">true</spanx>,
              and <spanx style="verb">false</spanx> present no challenge since they already have a
              fixed definition in JSON <xref target="RFC8259"/>.
            </t>
          </section>
          <section anchor="json.ser.string" title="Serialization of Strings">
            <t>
              For JSON String data (which includes
              JSON&nbsp;Object property names as well), each Unicode code point MUST be serialized as
              described below (also matching Section 24.3.2.2 of <xref target="ES6"/>):
            </t>
            <t>
              <list style="symbols">
                <t>
                  If the Unicode value falls within the traditional ASCII control
                  character range (U+0000 through U+001F), it MUST
                  be serialized using lowercase hexadecimal Unicode notation (\uhhhh) unless it is in the
                  set of predefined JSON control characters U+0008, U+0009, U+000A, U+000C or U+000D
                  which MUST be serialized as \b, \t, \n, \f and \r respectively.
                </t>
                <t>
                  If the Unicode value is outside of the ASCII control character range, it MUST
                  be serialized "as&nbsp;is" unless it is equivalent to
                  U+005C&nbsp;(\) or U+0022&nbsp;(") which MUST be serialized as \\ and \" respectively.
                </t>
              </list>
            </t>
            <t>
              Finally, the resulting sequence of Unicode code points MUST be enclosed in double quotes (").
            </t>
            <t>
              Note: some JSON systems permit the use of invalid Unicode data
              including "lone&nbsp;surrogates" (e.g. U+DEAD).
              Since this leads to interoperability issues including broken signatures,
              occurrences of such data MUST cause the JCS algorithm to terminate
              with an error indication.
            </t>
          </section>

          <section anchor="json.ser.number" title="Serialization of Numbers">
            <t>
              JSON Number data MUST be serialized according to
              Section 7.1.12.1 of <xref target="ES6"/> including the "Note 2" enhancement.
            </t>
            <t>
              Due to the relative complexity of this part, the algorithm itself is not included in this document.
              However, the specification is fully implemented by for example Google's V8 <xref target="V8"/>.
              The open source Java implementation mentioned in <xref target="open.source"/>
              uses a recently developed number serialization algorithm called Ryu <xref target="RYU"/>.
            </t>
            <t>
              ES6 builds on the IEEE-754 <xref target="IEEE754"/> double precision
              standard for representing JSON Number data.
              <xref target="json.ieee754.test"/> holds a set of IEEE-754 sample values and their
              corresponding JSON serialization.
            </t>
            <t>
              Note: since NaN (Not a Number) and Infinity are not permitted in JSON,
              occurrences of such values MUST cause the JCS algorithm to terminate
              with an error indication.
            </t>
        </section>
        </section>
        <section anchor="json.sorting.properties" title="Sorting of Object Properties">
          <t>
            Although the previous step indeed normalized the representation of primitive
            JSON data types, the result would not qualify as "canonical" since JSON
            Object properties are not in lexicographic (alphabetical) order.
          </t>
          <t>
            Applied to the sample in <xref target="json.serialization.data"/>,
            a properly canonicalized version should (with a
            line wrap added for display purposes only), read as:
          </t>
          <t>
            <figure align="center"><artwork><![CDATA[  {"literals":[null,true,false],"numbers":[333333333.3333333,
  1e+30,4.5,0.002,1e-27],"string":"EURO$\u000f\nA'B\"\\\\\"/"}]]></artwork></figure>
          </t>
          <t>
            <list style="empty">
              <t>
                Note: EURO denotes a single Euro character (Unicode: U+20AC),
                <vspace blankLines="0"/>
                which not being ASCII, is currently not displayable in RFCs.
              </t>
            </list>
              </t>
          <t>
            The rules for lexicographic sorting of JSON Object
            properties according to JCS are as follows:
            <list style="symbols">
              <t>
                JSON Object properties MUST be sorted in a recursive manner
                which means that possible JSON child Objects
                MUST have their properties sorted as well.
              </t>
              <t>
                JSON Array data MUST also be scanned for
                presence of JSON Objects (and applying associated property sorting),
                but array element order MUST NOT be changed.
              </t>
            </list>
          </t>
          <t>
            When a JSON Object is about to have its properties
            sorted, the following measures MUST be adhered to:
            <list style="symbols">
              <t>
                The sorting process is applied to property name strings in their "raw" (unescaped) form.
                That is, a newline character is treated as U+000A.
              </t>
              <t>
                Property name strings to be sorted are formatted
                as arrays of UTF-16 <xref target="UNICODE"/> code units.
                The sorting is based on pure value comparisons, where code units are treated as
                unsigned integers, independent of locale settings.
              </t>
              <t>
                Property name strings either have different values at some index that is
                a valid index for both strings, or their lengths are different, or both.
                If they have different values at one or more index
                positions, let k be the smallest such index; then the string whose
                value at position k has the smaller value, as determined by using
                the &lt; operator, lexicographically precedes the other string.
                If there is no index position at which they differ,
                then the shorter string lexicographically precedes the longer string.
                <vspace blankLines="1"/>
                In plain English this means that property names are sorted in ascending order like the following:
              </t>
            </list>
          </t>
          <t>
            <figure align="center"><artwork><![CDATA[        ""
        "a"
        "aa"
        "ab"]]></artwork>
            </figure>
          </t>
          <t>
            The rationale for basing the sorting algorithm on UTF-16 code units is that
            it maps directly to the string type in ECMAScript (featured in Web browsers
            and Node.js), Java and .NET.
            Systems using another internal representation of string data will need to convert
            JSON property name strings into arrays of UTF-16 code units before sorting.
            The conversion from UTF-8 or UTF-32 to UTF-16 is defined by the
            Unicode <xref target="UNICODE"/> standard.
          </t>
          <t>
            Note: for the purpose of obtaining a deterministic property order, sorting on
            UTF-8 or UTF-32 encoded data would also work, but the result would differ
            (and thus be incompatible with this specification).
          </t>
        </section>
        <section anchor="json.utf8" title="UTF-8 Generation">
          <t>
            Finally, in order to create a platform independent representation,
            the result of the preceding step MUST be encoded in UTF-8.
          </t>
          <t>
            Applied to the sample in <xref target="json.sorting.properties"/> this
            should yield the following bytes here shown in hexadecimal notation:
          </t>
          <t>
            <figure align="center"><artwork><![CDATA[  7b 22 6c 69 74 65 72 61 6c 73 22 3a 5b 6e 75 6c 6c 2c 74 72
  75 65 2c 66 61 6c 73 65 5d 2c 22 6e 75 6d 62 65 72 73 22 3a
  5b 33 33 33 33 33 33 33 33 33 2e 33 33 33 33 33 33 33 2c 31
  65 2b 33 30 2c 34 2e 35 2c 30 2e 30 30 32 2c 31 65 2d 32 37
  5d 2c 22 73 74 72 69 6e 67 22 3a 22 e2 82 ac 24 5c 75 30 30
  30 66 5c 6e 41 27 42 5c 22 5c 5c 5c 5c 5c 22 2f 22 7d]]></artwork></figure>
          </t>
          <t>
            This data is intended to be usable as input to cryptographic methods.
          </t>
        </section>
      </section>
    </section>

    <section anchor="IANA" title="IANA Considerations">
      <t>
        This document has no IANA actions.
      </t>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t>
        It is vital performing "sanity" checks
        on input data to avoid overflowing buffers and similar things that
        could affect the integrity of the system.
      </t>
    </section>

    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>
        Building on ES6 Number serialization was
        originally proposed by James&nbsp;Manger. This ultimately led to the
        adoption of the entire ES6 serialization scheme for JSON primitives.
      </t>
      <t>
        Other people who have contributed with valuable input to this specification include
        Scott&nbsp;Ananian, Richard&nbsp;Gibson, Bron&nbsp;Gondwana, John-Mark&nbsp;Gurney, Mike&nbsp;Jones,
        Mike&nbsp;Miller, Mark&nbsp;Nottingham, Mike&nbsp;Samuel, Jim&nbsp;Schaad,
        Robert&nbsp;Tupelo-Schneck and Michal&nbsp;Wadas.
      </t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include='reference.RFC.2119'?>
      <?rfc include='reference.RFC.8259'?>
      <?rfc include='reference.RFC.8174'?>
      <?rfc include='reference.RFC.7493'?>

      <reference anchor="ES6" target="https://www.ecma-international.org/ecma-262/6.0/index.html">
        <front>
          <title>ECMAScript 2015 Language Specification</title>
          <author>
            <organization>Ecma International</organization>
          </author>
          <date/>
        </front>
      </reference>
      <reference anchor="IEEE754" target="http://grouper.ieee.org/groups/754/">
        <front>
          <title>IEEE Standard for Floating-Point Arithmetic</title>
          <author>
            <organization>IEEE</organization>
          </author>
          <date month="August" year="2008"/>
        </front>
      </reference>
      <reference anchor="UNICODE" target="https://www.unicode.org/versions/Unicode10.0.0/">
        <front>
          <title>The Unicode Standard, Version 10.0.0</title>
          <author>
            <organization>The Unicode Consortium</organization>
          </author>
          <date/>
        </front>
      </reference>
    </references>
    <references title="Informal References">
      <?rfc include='reference.RFC.7638'?>
      <?rfc include='reference.RFC.4648'?>
      <?rfc include='reference.RFC.7515'?>
      <reference anchor="JSONCOMP" target="https://tools.ietf.org/html/draft-rundgren-comparable-json-04">
        <front>
          <title>"Comparable" JSON - Work in progress</title>
          <author>
            <organization>A. Rundgren</organization>
          </author>
          <date/>
        </front>
      </reference>
      <reference anchor="V8" target="https://developers.google.com/v8/">
        <front>
          <title>Chrome V8 Open Source JavaScript Engine</title>
          <author>
            <organization>Google LLC</organization>
          </author>
          <date/>
        </front>
      </reference>
      <reference anchor="RYU" target="https://github.com/ulfjack/ryu">
        <front>
          <title>Ryu floating point number serializing algorithm</title>
          <author>
            <organization>Ulf Adams</organization>
          </author>
          <date/>
        </front>
      </reference>
      <reference anchor="NODEJS" target="https://nodejs.org">
        <front>
          <title>Node.js</title>
          <author/>
          <date/>
        </front>
      </reference>
      <reference anchor="KEYBASE" target="https://keybase.io/docs/api/1.0/canonical_packings#json">
        <front>
          <title>Keybase</title>
          <author/>
          <date/>
        </front>
      </reference>
      <reference anchor="OPENAPI" target="https://www.openapis.org/">
        <front>
          <title>The OpenAPI Initiative</title>
          <author/>
          <date/>
        </front>
      </reference>
      <reference anchor="XMLDSIG" target="https://www.w3.org/TR/xmldsig-core1/">
        <front>
          <title>XML Signature Syntax and Processing Version 1.1</title>
          <author>
            <organization>W3C</organization>
          </author>
          <date/>
        </front>
      </reference>
    </references>

    <section anchor="canonicalize.js" title="ES6 Sample Canonicalizer">
      <t>
        Below is an example of a JCS canonicalizer for usage with ES6 based systems:
      </t>
      <t>
        <figure align="center"><artwork><![CDATA[  ////////////////////////////////////////////////////////////
  // Since the primary purpose of this code is highlighting //
  // the core of the JCS algorithm, error handling and      //
  // UTF-8 generation were not implemented                  //
  ////////////////////////////////////////////////////////////
  var canonicalize = function(object) {
  
      var buffer = '';
      serialize(object);
      return buffer;
  
      function serialize(object) {
          if (object === null || typeof object !== 'object' ||
              object.toJSON != null) {
              /////////////////////////////////////////////////
              // Primitive type or toJSON - Use ES6/JSON     //
              /////////////////////////////////////////////////
              buffer += JSON.stringify(object);
  
          } else if (Array.isArray(object)) {
              /////////////////////////////////////////////////
              // Array - Maintain element order              //
              /////////////////////////////////////////////////
              buffer += '[';
              let next = false;
              object.forEach((element) => {
                  if (next) {
                      buffer += ',';
                  }
                  next = true;
                  /////////////////////////////////////////
                  // Array element - Recursive expansion //
                  /////////////////////////////////////////
                  serialize(element);
              });
              buffer += ']';
  
          } else {
              /////////////////////////////////////////////////
              // Object - Sort properties before serializing //
              /////////////////////////////////////////////////
              buffer += '{';
              let next = false;
              Object.keys(object).sort().forEach((property) => {
                  if (next) {
                      buffer += ',';
                  }
                  next = true;
                  ///////////////////////////////////////////////
                  // Property names are strings - Use ES6/JSON //
                  ///////////////////////////////////////////////
                  buffer += JSON.stringify(property);
                  buffer += ':';
                  //////////////////////////////////////////
                  // Property value - Recursive expansion //
                  //////////////////////////////////////////
                  serialize(object[property]);
              });
              buffer += '}';
          }
      }
  };]]></artwork></figure>
      </t>
    </section>
 
    <section anchor="json.ieee754.test" title="Number Serialization Samples">
      <t>
        The following table holds a set of ES6 compatible Number serialization samples,
        including some edge cases.  The column
        "IEEE&nbhy;754" refers to the internal
        ES6 representation of the Number data type which is based on the
        IEEE-754 <xref target="IEEE754"/> standard using 64-bit (double precision) values,
        here expressed in hexadecimal.
      </t>
      <t>
        <figure align="center"><artwork><![CDATA[|====================================================================|
|     IEEE-754     |   JSON Representation     |       Comment       |
|====================================================================|
| 0000000000000000 | 0                         | Zero                |
|--------------------------------------------------------------------|
| 8000000000000000 | 0                         | Minus zero          |
|--------------------------------------------------------------------|
| 0000000000000001 | 5e-324                    | Min pos number      |
|--------------------------------------------------------------------|
| 8000000000000001 | -5e-324                   | Min neg number      |
|--------------------------------------------------------------------|
| 7fefffffffffffff | 1.7976931348623157e+308   | Max pos number      |
|--------------------------------------------------------------------|
| ffefffffffffffff | -1.7976931348623157e+308  | Max neg number      |
|--------------------------------------------------------------------|
| 4340000000000000 | 9007199254740992          | Max pos integer (1) |
|--------------------------------------------------------------------|
| c340000000000000 | -9007199254740992         | Max neg integer (1) |
|--------------------------------------------------------------------|
| 4430000000000000 | 295147905179352830000     | ~2**68          (2) |
|--------------------------------------------------------------------|
| 7fffffffffffffff |                           | NaN - Invalid       |
|--------------------------------------------------------------------|
| 7ff0000000000000 |                           | Infinity - Invalid  |
|--------------------------------------------------------------------|
| 44b52d02c7e14af5 | 9.999999999999997e+22     |                     |
|--------------------------------------------------------------------|
| 44b52d02c7e14af6 | 1e+23                     |                     |
|--------------------------------------------------------------------|
| 44b52d02c7e14af7 | 1.0000000000000001e+23    |                     |
|--------------------------------------------------------------------|
| 444b1ae4d6e2ef4e | 999999999999999700000     |                     |
|--------------------------------------------------------------------|
| 444b1ae4d6e2ef4f | 999999999999999900000     |                     |
|--------------------------------------------------------------------|
| 444b1ae4d6e2ef50 | 1e+21                     |                     |
|--------------------------------------------------------------------|
| 3eb0c6f7a0b5ed8c | 9.999999999999997e-7      |                     |
|--------------------------------------------------------------------|
| 3eb0c6f7a0b5ed8d | 0.000001                  |                     |
|--------------------------------------------------------------------|
| 41b3de4355555553 | 333333333.3333332         |                     |
|--------------------------------------------------------------------|
| 41b3de4355555554 | 333333333.33333325        |                     |
|--------------------------------------------------------------------|
| 41b3de4355555555 | 333333333.3333333         |                     |
|--------------------------------------------------------------------|
| 41b3de4355555556 | 333333333.3333334         |                     |
|--------------------------------------------------------------------|
| 41b3de4355555557 | 333333333.33333343        |                     |
|--------------------------------------------------------------------|
| becbf647612f3696 | -0.0000033333333333333333 |                     |
|--------------------------------------------------------------------|]]></artwork></figure>
      </t>
      <t>
        Notes:
        <list style="format (%d)">
        <t>
          For maximum compliance with the ES6 <spanx style="verb">JSON</spanx> object
          values that are to be interpreted as true integers
          SHOULD be in the range -9007199254740991 to 9007199254740991.
          However, how numbers are used in applications do not affect the JCS algorithm.
        </t>
        <t>
          Although a set of specific integers like 2**68 could be regarded as having
          extended precision, the JCS/ES6 number serialization
          algorithm does not take this in consideration.
        </t>
        </list>
      </t>
    </section>
    
    <section anchor="json.wireformat" title="Canonicalized JSON as &quot;Wire Format&quot;">
      <t>
        Since the result from the canonicalization process (see <xref target="json.utf8"/>),
        is fully valid JSON, it can also be used as "Wire&nbsp;Format".
        However, this is just an option since cryptographic schemes
        based on JCS, in most cases would not depend on that externally
        supplied JSON data already is canonicalized.
      </t>
      <t>
        In fact, the ES6 standard way of serializing objects using
        <spanx style="verb">JSON.stringify()</spanx> produces a
        more "logical" format, where properties are
        kept in the order they were created or received.  The
        example below shows an address record which could benefit from
        ES6 standard serialization:
      </t>
      <t>
        <figure align="center"><artwork><![CDATA[  {
    "name": "John Doe",
    "address": "2000 Sunset Boulevard",
    "city": "Los Angeles",
    "zip": "90001",
    "state": "CA"
  }]]></artwork></figure>
      </t>
      <t>
        Using canonicalization the properties above would be output in the order
        "address", "city", "name", "state" and "zip", which adds fuzziness
        to the data from a human (developer or technical support), perspective.
      </t>
      <t>
        That is, for many applications, canonicalization would only be used internally
        for creating a "hashable" representation of the data needed for cryptographic
        operations.
      </t>
      <t>
        Note: if message size is not a concern, you may even send "Pretty&nbsp;Printed"
        JSON data on the wire.
      </t>
    </section>

    <section anchor="json.bignumbers" title="Dealing with Big Numbers">
      <t>
        There are several issues associated with the
        JSON Number type, here illustrated by the following
        sample object:
      </t>
      <t>
        <figure align="center"><artwork><![CDATA[  {
    "giantNumber": 1.4e+9999,
    "payMeThis": 26000.33,
    "int64Max": 9223372036854775807
  }]]></artwork></figure>
      </t>
      <t>
        Although the sample above conforms to JSON <xref target="RFC8259"/>,
        applications would normally use different native data types for storing
        "giantNumber" and "int64Max".  In addition, monetary data like "payMeThis" would
        presumably not rely on floating point data types due to rounding issues with respect
        to decimal arithmetic.
      </t>
      <t>
        The established way handling this kind of "overloading" of the
        JSON Number type (at least in an extensible manner), is through
        mapping mechanisms, instructing parsers what to do with different properties
        based on their name.  However, this greatly limits the value of using the
        Number type outside of its original somewhat constrained, JavaScript context.
        The ES6 <spanx style="verb">JSON</spanx> object does not support mappings to JSON Number either.
      </t>
      <t>
        Due to the above, numbers that do not have a natural place in the current
        JSON ecosystem MUST be wrapped using the JSON String type.  This is close to
        a de-facto standard for open systems.  This is also applicable for
        other data types that do not have direct support in JSON, like "DateTime"
        objects as described in <xref target="string.subtypes"/>.
      </t>
      <t>
        Aided by a system using the JSON String type; be it programmatic like
      </t>
      <t>
          <figure align="center">
            <artwork><![CDATA[  var obj = JSON.parse('{"giantNumber": "1.4e+9999"}');
  var biggie = new BigNumber(obj.giantNumber);]]></artwork></figure>
      </t>
      <t>
        or declarative schemes like OpenAPI <xref target="OPENAPI"/>,
        JCS imposes no limits on applications, including when using ES6.
      </t>
    </section>

    <section anchor="string.subtypes" title="String Subtype Handling">
      <t>
        Due to the limited set of data types featured in JSON,
        the JSON String type is commonly used for holding subtypes.
        This can depending on JSON parsing method lead to
        interoperability problems which MUST be dealt with by
        JCS compliant applications targeting a wider audience.
      </t>
      <t>
        Assume you want parse a JSON object where the schema
        designer assigned the property "big" for holding a "BigInteger" subtype and
        "time" for holding a "DateTime" subtype, while "val" is supposed to be a JSON Number
        compliant with JCS. The following example shows such an object:
      </t>
      <t>
        <figure align="center"><artwork><![CDATA[  {
    "time": "2019-01-28T07:45:10Z",
    "big": "055", 
    "val": 3.5
  }]]></artwork></figure>
      </t>
      <t>Parsing of this object can accomplished by the following ES6 statement:</t>
      <t>
        <figure align="center"><artwork><![CDATA[  var object = JSON.parse(JSON-data-featured-as-a-string);]]></artwork></figure>
      </t>
      <t>After parsing the actual data can be extracted which for subtypes also involve a conversion
      step using the result of the parsing process (an ECMAScript object) as input:</t>
      <t>
        <figure align="center"><artwork><![CDATA[  ... = new Date(object.time); // Date object
  ... = BigInt(object.big);    // Big integer
  ... = object.val;            // JSON/JS number]]></artwork></figure>
      </t>
      <t>Canonicalization of "object" using the sample code in <xref target="canonicalize.js"/> would return the
      following string:</t>
      <t>
        <figure align="center"><artwork><![CDATA[  {"big":"055","time":"2019-01-28T07:45:10Z",val:3.5}]]></artwork></figure>
      </t>
      <t>
        Although this is (with respect to JCS) technically correct, there is another way parsing JSON data
        which also can be used with ES6 as shown below:
      </t>
      <t>
        <figure align="center"><artwork><![CDATA[  // Currently required to make BigInt JSON serializable
  BigInt.prototype.toJSON = function() {
      return this.toString();
  };

  // JSON parsing using a "stream" based method
  var object = JSON.parse(JSON-data-featured-as-a-string, 
      (k,v) => k == 'time' ? new Date(v) : k == 'big' ? BigInt(v) : v
  );]]></artwork></figure>
      </t>
      <t>
        If you now apply the canonicalizer in <xref target="canonicalize.js"/> to  "object", the
        following string would be generated:
      </t>
      <t>
        <figure align="center"><artwork><![CDATA[  {"big":"55","time":"2019-01-28T07:45:10.000Z","val":3.5}]]></artwork></figure>
      </t>
      <t>
        In this case the string arguments for "big" and "time" have changed with respect to the original,
        presumable making an application depending on JCS fail.
      </t>
      <t>
        The reason for the deviation is that in stream and schema based JSON parsers,
        the original "string" argument is typically replaced on-the-fly
        by the native subtype which when serialized, may exhibit a different
        and platform dependent pattern.
      </t>
      <t>
        That is, stream and schema based parsing MUST treat subtypes as "pure" (immutable) JSON String types,
        and perform the actual conversion to the designated native type in a subsequent step.
        In modern programming platforms like Go, Java and C# this can be achieved with
        moderate efforts by combining annotations, getters and setters.
        Below is an example in C#/Json.NET showing a part of a class that is serializable
        as a JSON Object:
      </t>
      <t>
        <figure align="center"><artwork><![CDATA[  // The "pure" string solution uses a local
  // string variable for JSON serialization while
  // exposing another type to the application
  [JsonProperty("amount")]
  private string _amount;

  [JsonIgnore]
  public decimal Amount {
      get { return decimal.Parse(_amount); }
      set { _amount = value.ToString(); }
  }]]></artwork></figure>
      </t>
      <t>
        In an application "Amount" can be accessed as any other property
        while it is actually represented by a quoted string in JSON contexts.
      </t>
      <t>
        Note: the example above also addresses the constraints on numeric data
        implied by I-JSON (the C# "decimal" data type has quite different
        characteristics compared to IEEE-754 double precision).
      </t>
      <section anchor="string.subtypes.arrays" title="Subtypes in Arrays">
        <t>
          Since the JSON Array construct permits mixing arbitrary JSON elements,
          custom parsing and serialization code must normally
          be used to cope with subtypes anyway.
        </t>
      </section>
    </section>

    <section anchor="impl.guidelines" title="Implementation Guidelines">
      <t>
        The optimal solution is integrating support for JCS directly
        in JSON serializers (parsers need no changes).
        That is, canonicalization would just be an additional "mode"
        for a JSON serializer. However, this is currently not the case.
        Fortunately JCS support can be performed through externally supplied
        canonicalizer software, enabling signature creation schemes like the following:
        <list style="numbers">
          <t>
            Create the data to be signed.
          </t>
          <t>
            Serialize the data using existing JSON tools.
          </t>
          <t>
            Let the external canonicalizer process the serialized data and return canonicalized result data.
          </t>
          <t>
            Sign the canonicalized data.
          </t>
          <t>
            Add the resulting signature value to the original JSON data through a designated signature property.
          </t>
          <t>
            Serialize the completed (now signed) JSON object using existing JSON tools.
          </t>
        </list>
        A compatible signature verification scheme would then be as follows:
        <list style="numbers">
          <t>
            Parse the signed JSON data using existing JSON tools.
          </t>
          <t>
            Read and save the signature value from the designated signature property.
          </t>
          <t>
            Remove the signature property from the parsed JSON object.
          </t>
          <t>
            Serialize the remaining JSON data using existing JSON tools.
          </t>
          <t>
            Let the external canonicalizer process the serialized data and return canonicalized result data.
          </t>
          <t>
            Verify that the canonicalized data matches the saved signature value
            using the algorithm and key used for creating the signature.
          </t>
        </list>
      </t>
      <t>
        A canonicalizer like above is effectively only a "filter", potentially usable with
        a multitude of quite different cryptographic schemes.
      </t>
      <t>
        Using a JSON serializer with integrated JCS support, the serialization performed
        before the canonicalization step could be eliminated for both processes.
      </t>
    </section>

    <section anchor="open.source" title="Open Source Implementations">
      <t>
        The following Open Source implementations have been verified to be
        compatible with JCS:
        <list style="symbols">
          <t>
            JavaScript: <eref target="https://www.npmjs.com/package/canonicalize">https://www.npmjs.com/package/canonicalize</eref>
          </t>
          <t>
            Java: <eref target="https://github.com/erdtman/java-json-canonicalization">https://github.com/erdtman/java-json-canonicalization</eref>
          </t>
          <t>
            Go: <eref target="https://github.com/cyberphone/json-canonicalization/tree/master/go">https://github.com/cyberphone/json-canonicalization/tree/master/go</eref>
          </t>
          <t>
            .NET/C#: <eref target="https://github.com/cyberphone/json-canonicalization/tree/master/dotnet">https://github.com/cyberphone/json-canonicalization/tree/master/dotnet</eref>
          </t>
          <t>
            Python: <eref target="https://github.com/cyberphone/json-canonicalization/tree/master/python3">https://github.com/cyberphone/json-canonicalization/tree/master/python3</eref>
          </t>
        </list>
      </t>
    </section>

    <section anchor="json.otherefforts" title="Other JSON Canonicalization Efforts">
      <t>
        There are (and have been) other efforts creating "Canonical JSON". 
        Below is a list of URLs to some of them:
        <list style="symbols">
          <t>
            <eref target="https://tools.ietf.org/html/draft-staykov-hu-json-canonical-form-00">https://tools.ietf.org/html/draft-staykov-hu-json-canonical-form-00</eref>
          </t>
          <t>
            <eref target="https://gibson042.github.io/canonicaljson-spec/">https://gibson042.github.io/canonicaljson-spec/</eref>
          </t>
          <t>
            <eref target="http://wiki.laptop.org/go/Canonical_JSON">http://wiki.laptop.org/go/Canonical_JSON</eref>
          </t>
        </list>
        In contrast to JCS which is a serialization scheme, the listed efforts build on text level JSON to JSON
        transformations. 
      </t>
    </section>

    <section anchor="json.development" title="Development Portal">
      <t>
        The JCS specification is currently developed at:
        <eref target="https://github.com/cyberphone/ietf-json-canon">https://github.com/cyberphone/ietf-json-canon</eref>.
      </t>
      <t>
        The most recent "editors' copy" can be found at:
        <eref target="https://cyberphone.github.io/ietf-json-canon">https://cyberphone.github.io/ietf-json-canon</eref>.
      </t>
      <t>
        JCS source code and test data is available at:
        <eref target="https://github.com/cyberphone/json-canonicalization">https://github.com/cyberphone/json-canonicalization</eref>
      </t>
    </section>
  </back>
</rfc>
