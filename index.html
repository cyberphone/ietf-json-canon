<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head profile="http://dublincore.org/documents/2008/08/04/dc-html/">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="robots" content="index,follow" />
    <meta name="creator" content="rfcmarkup version 1.129c" />
    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" />

    <link rel="icon" href="" type="image/png" />
    <link rel="shortcut icon" href="" type="image/png" />
    <title>draft-rundgren-json-canonicalization-scheme-2.txt - JSON Canonicalization Scheme (JCS)</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div onmouseover="this.style.cursor='pointer';"
         onclick="showElem('legend');"
         onmouseout="hideElem('legend')"
	 style="height: 6px; position: absolute;"
         class="pre noprint docinfo "
         title="Click for colour legend." >                                                                        </div>
      <div id="legend"
           class="docinfo noprint pre legend"
           style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; "
           onmouseover="showElem('legend');"
           onmouseout="hideElem('legend');">
      </div>
   </div>

<span class="pre noprint docinfo">                                                                        </span><br />
<span class="pre noprint docinfo">                                                                        </span><br />
<span class="pre noprint docinfo">                                                                        </span><br />
<pre>
Network Working Group                                        A. Rundgren
Internet-Draft                                               Independent
Intended status: Informational                                 B. Jordan
Expires: 16 March 2020                              Symantec Corporation
                                                              S. Erdtman
                                                              Spotify AB
                                                       13 September 2019


                   <span class="h1">JSON Canonicalization Scheme (JCS)</span>
             <span class="h1">draft-rundgren-json-canonicalization-scheme-08</span>

Abstract

   Cryptographic operations like hashing and signing requires that the
   original data does not change during serialization or parsing.  One
   way addressing this issue is creating a canonical form of the data.
   Canonicalization also permits data to be exchanged in its original
   form on the "wire" while secure cryptographic operations are
   performed on its canonicalized counterpart in the producer and
   consumer end points.  The JSON Canonicalization Scheme (JCS) provides
   canonicalization support for data in the JSON format by building on
   the strict serialization methods for JSON primitives defined by
   ECMAScript, constraining JSON data to the I-JSON subset, and through
   a deterministic property sorting scheme.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of <a href="http://tools.ietf.org/html//bcp78">BCP 78</a> and <a href="http://tools.ietf.org/html//bcp79">BCP 79</a>.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at <a href="https://datatracker.ietf.org/drafts/current/">https://datatracker.ietf.org/drafts/current/</a>.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 16 March 2020.

Copyright Notice

   Copyright (c) 2019 IETF Trust and the persons identified as the
   document authors.  All rights reserved.




<span class="grey">Rundgren, et al.          Expires 16 March 2020                 [Page 1]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-2" id="page-2" href="#page-2" class="invisible"> </a>
<span class="grey">Internet-Draft <a href="http://tools.ietf.org/html//draft-rundgren-json-canonicalization-schemeSeptember">draft-rundgren-json-canonicalization-schemeSeptember</a> 2019</span>


   This document is subject to <a href="http://tools.ietf.org/html//bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents (<a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/</a>
   <a href="https://trustee.ietf.org/license-info">license-info</a>) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Simplified BSD License text
   as described in Section 4.e of the <a href="https://trustee.ietf.org/license-info">Trust Legal Provisions</a> and are
   provided without warranty as described in the Simplified BSD License.

Table of Contents

   <a href="#section-1">1</a>.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-3">3</a>
   <a href="#section-2">2</a>.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-4">4</a>
   <a href="#section-3">3</a>.  Detailed Operation  . . . . . . . . . . . . . . . . . . . . .   <a href="#page-4">4</a>
     <a href="#section-3.1">3.1</a>.  Creation of Input Data  . . . . . . . . . . . . . . . . .   <a href="#page-4">4</a>
     <a href="#section-3.2">3.2</a>.  Generation of Canonical JSON Data . . . . . . . . . . . .   <a href="#page-5">5</a>
       <a href="#section-3.2.1">3.2.1</a>.  Whitespace  . . . . . . . . . . . . . . . . . . . . .   <a href="#page-5">5</a>
       <a href="#section-3.2.2">3.2.2</a>.  Serialization of Primitive Data Types . . . . . . . .   <a href="#page-5">5</a>
         <a href="#section-3.2.2.1">3.2.2.1</a>.  Serialization of Literals . . . . . . . . . . . .   <a href="#page-5">5</a>
         <a href="#section-3.2.2.2">3.2.2.2</a>.  Serialization of Strings  . . . . . . . . . . . .   <a href="#page-6">6</a>
         <a href="#section-3.2.2.3">3.2.2.3</a>.  Serialization of Numbers  . . . . . . . . . . . .   <a href="#page-6">6</a>
       <a href="#section-3.2.3">3.2.3</a>.  Sorting of Object Properties  . . . . . . . . . . . .   <a href="#page-7">7</a>
       <a href="#section-3.2.4">3.2.4</a>.  UTF-8 Generation  . . . . . . . . . . . . . . . . . .   <a href="#page-9">9</a>
   <a href="#section-4">4</a>.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .   <a href="#page-9">9</a>
   <a href="#section-5">5</a>.  Security Considerations . . . . . . . . . . . . . . . . . . .   <a href="#page-9">9</a>
   <a href="#section-6">6</a>.  Acknowledgements  . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-9">9</a>
   <a href="#section-7">7</a>.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-10">10</a>
     <a href="#section-7.1">7.1</a>.  Normative References  . . . . . . . . . . . . . . . . . .  <a href="#page-10">10</a>
     <a href="#section-7.2">7.2</a>.  Informal References . . . . . . . . . . . . . . . . . . .  <a href="#page-10">10</a>
   <a href="#appendix-A">Appendix A</a>.  ES6 Sample Canonicalizer . . . . . . . . . . . . . .  <a href="#page-11">11</a>
   <a href="#appendix-B">Appendix B</a>.  Number Serialization Samples . . . . . . . . . . . .  <a href="#page-13">13</a>
   <a href="#appendix-C">Appendix C</a>.  Canonicalized JSON as "Wire Format"  . . . . . . . .  <a href="#page-14">14</a>
   <a href="#appendix-D">Appendix D</a>.  Dealing with Big Numbers . . . . . . . . . . . . . .  <a href="#page-15">15</a>
   <a href="#appendix-E">Appendix E</a>.  String Subtype Handling  . . . . . . . . . . . . . .  <a href="#page-16">16</a>
     <a href="#appendix-E.1">E.1</a>.  Subtypes in Arrays  . . . . . . . . . . . . . . . . . . .  <a href="#page-18">18</a>
   <a href="#appendix-F">Appendix F</a>.  Implementation Guidelines  . . . . . . . . . . . . .  <a href="#page-18">18</a>
   <a href="#appendix-G">Appendix G</a>.  Open Source Implementations  . . . . . . . . . . . .  <a href="#page-19">19</a>
   <a href="#appendix-H">Appendix H</a>.  Other JSON Canonicalization Efforts  . . . . . . . .  <a href="#page-19">19</a>
   <a href="#appendix-I">Appendix I</a>.  Development Portal . . . . . . . . . . . . . . . . .  <a href="#page-20">20</a>
   <a href="#appendix-J">Appendix J</a>.  Document History . . . . . . . . . . . . . . . . . .  <a href="#page-20">20</a>
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-21">21</a>










<span class="grey">Rundgren, et al.          Expires 16 March 2020                 [Page 2]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-3" id="page-3" href="#page-3" class="invisible"> </a>
<span class="grey">Internet-Draft <a href="http://tools.ietf.org/html//draft-rundgren-json-canonicalization-schemeSeptember">draft-rundgren-json-canonicalization-schemeSeptember</a> 2019</span>


<span class="h2"><a class="selflink" name="section-1" href="#section-1">1</a>.  Introduction</span>

   Cryptographic operations like hashing and signing requires that the
   original data does not change during serialization or parsing.  One
   way of accomplishing this is converting the data into a format that
   has a simple and fixed representation like Base64Url [<a href="http://tools.ietf.org/html//rfc4648" title="&quot;The Base16, Base32, and Base64 Data Encodings&quot;">RFC4648</a>], which
   is how JWS [<a href="http://tools.ietf.org/html//rfc7515" title="&quot;JSON Web Signature (JWS)&quot;">RFC7515</a>] addressed this issue.

   Another solution is to create a canonical version of the data,
   similar to what was done for the XML Signature [<a href="#ref-XMLDSIG" title="&quot;XML Signature Syntax and Processing Version 1.1&quot;">XMLDSIG</a>] standard.
   The primary advantage with a canonicalizing scheme is that data can
   be kept in its original form.  This is the core rationale behind JCS.
   Put another way: by using canonicalization a JSON Object may remain a
   JSON Object even after being signed which simplifies system design,
   documentation and logging.

   To avoid "reinventing the wheel", JCS relies on serialization of JSON
   primitives compatible with ECMAScript (aka JavaScript) beginning with
   version 6 [<a href="#ref-ES6" title="&quot;ECMAScript 2015 Language Specification&quot;">ES6</a>], hereafter referred to as "ES6".

   Seasoned XML developers recalling difficulties getting signatures to
   validate (usually due to different interpretations of the quite
   intricate XML canonicalization rules as well as of the equally
   extensive Web Services security standards), may rightfully wonder why
   JCS would not suffer from similar issues.  The reasons are twofold:

   •  The absence of a namespace concept and default values, as well as
      constraining data to the I-JSON subset eliminate the need for
      specific parsers for dealing with canonicalization.

   •  JCS compatible serialization of JSON primitives is supported by
      most current Web browsers and as well as by Node.js [<a href="#ref-NODEJS" title="&quot;Node.js&quot;">NODEJS</a>],
      while the full JCS specification is supported by multiple Open
      Source implementations (see <a href="#appendix-G">Appendix G</a>).  See also <a href="#appendix-F">Appendix F</a>.

   In summary the JCS specification describes how serialization of JSON
   primitives compliant with ES6 combined with a deterministic property
   sorting scheme can be used for creating "Hashable" representations of
   JSON data intended for consumption by cryptographic methods.

   JCS is compatible with some existing systems relying on JSON
   canonicalization such as JWK Thumbprint [<a href="http://tools.ietf.org/html//rfc7638" title="&quot;JSON Web Key (JWK) Thumbprint&quot;">RFC7638</a>] and Keybase
   [<a href="#ref-KEYBASE" title="&quot;Keybase&quot;">KEYBASE</a>].

   For potential uses outside of cryptography see [<a href="#ref-JSONCOMP" title="&quot;Comparable&quot;">JSONCOMP</a>].

   The intended audiences of this document are JSON tool vendors, as
   well as designers of JSON based cryptographic solutions.  The reader



<span class="grey">Rundgren, et al.          Expires 16 March 2020                 [Page 3]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-4" id="page-4" href="#page-4" class="invisible"> </a>
<span class="grey">Internet-Draft <a href="http://tools.ietf.org/html//draft-rundgren-json-canonicalization-schemeSeptember">draft-rundgren-json-canonicalization-schemeSeptember</a> 2019</span>


   is assumed to have a basic knowledge of ECMAScript including the
   "JSON" object.

<span class="h2"><a class="selflink" name="section-2" href="#section-2">2</a>.  Terminology</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in <a href="http://tools.ietf.org/html//bcp14">BCP</a>
   <a href="http://tools.ietf.org/html//bcp14">14</a> [<a href="http://tools.ietf.org/html//rfc2119" title="&quot;Key words for use in RFCs to Indicate Requirement Levels&quot;">RFC2119</a>] [<a href="http://tools.ietf.org/html//rfc8174" title="&quot;Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words&quot;">RFC8174</a>] when, and only when, they appear in all
   capitals, as shown here.

<span class="h2"><a class="selflink" name="section-3" href="#section-3">3</a>.  Detailed Operation</span>

   This section describes the different issues related to creating a
   canonical JSON representation, and how they are addressed by JCS.

<span class="h3"><a class="selflink" name="section-3.1" href="#section-3.1">3.1</a>.  Creation of Input Data</span>

   Data to be serialized is usually achieved by:

   •  Parsing previously generated JSON data.

   •  Programmatically creating data.

   Irrespective of the method used, the data to be serialized MUST be
   adapted for I-JSON [<a href="http://tools.ietf.org/html//rfc7493" title="&quot;The I-JSON Message Format&quot;">RFC7493</a>] formatting, which implies the following:

   •  JSON Objects MUST NOT exhibit duplicate property names.

   •  JSON String data MUST be expressible as Unicode [<a href="#ref-UNICODE" title="&quot;The Unicode Standard, Version 12.1.0&quot;">UNICODE</a>].

   •  JSON Number data MUST be expressible as IEEE-754 [<a href="#ref-IEEE754" title="&quot;IEEE Standard for Floating-Point Arithmetic&quot;">IEEE754</a>] double
      precision values.  For applications needing higher precision or
      longer integers than offered by IEEE-754 double precision,
      <a href="#appendix-D">Appendix D</a> outlines how such requirements can be supported in an
      interoperable and extensible way.

   An additional constraint is that parsed JSON String data MUST NOT be
   altered during subsequent serializations.  For more information see
   <a href="#appendix-E">Appendix E</a>.

   Note: although the Unicode standard offers a possibility combining
   certain characters into one, referred to as "Unicode Normalization"
   (<a href="https://www.unicode.org/reports/tr15/">https://www.unicode.org/reports/tr15/</a>), JCS' string processing does
   not take this in consideration.  That is, all components involved in
   a scheme depending on JCS, MUST preserve Unicode string data "as is".





<span class="grey">Rundgren, et al.          Expires 16 March 2020                 [Page 4]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-5" id="page-5" href="#page-5" class="invisible"> </a>
<span class="grey">Internet-Draft <a href="http://tools.ietf.org/html//draft-rundgren-json-canonicalization-schemeSeptember">draft-rundgren-json-canonicalization-schemeSeptember</a> 2019</span>


   Note: how structured objects like sets are represented in JSON is out
   of scope for JCS.  See also <a href="#appendix-F">Appendix F</a>.

<span class="h3"><a class="selflink" name="section-3.2" href="#section-3.2">3.2</a>.  Generation of Canonical JSON Data</span>

   The following subsections describe the steps required for creating a
   canonical JSON representation of the data elaborated on in the
   previous section.

   <a href="#appendix-A">Appendix A</a> shows sample code for an ES6 based canonicalizer, matching
   the JCS specification.

<span class="h4"><a class="selflink" name="section-3.2.1" href="#section-3.2.1">3.2.1</a>.  Whitespace</span>

   Whitespace between JSON tokens MUST NOT be emitted.

<span class="h4"><a class="selflink" name="section-3.2.2" href="#section-3.2.2">3.2.2</a>.  Serialization of Primitive Data Types</span>

   Assume that you parse a JSON object like the following:

     {
       "numbers": [333333333.33333329, 1E30, 4.50,
                   2e-3, 0.000000000000000000000000001],
       "string": "\u20ac$\u000F\u000aA'\u0042\u0022\u005c\\\"\/",
       "literals": [null, true, false]
     }

   If you subsequently serialize the parsed data using a serializer
   compliant with ES6's "JSON.stringify()", the result would (with a
   line wrap added for display purposes only), be rather divergent with
   respect to representation of data:

     {"numbers":[333333333.3333333,1e+30,4.5,0.002,1e-27],"string":
     "€$\u000f\nA'B\"\\\\\"/","literals":[null,true,false]}

   The reason for the difference between the parsed data and its
   serialized counterpart, is due to a wide tolerance on input data (as
   defined by JSON [<a href="http://tools.ietf.org/html//rfc8259" title="&quot;The JavaScript Object Notation (JSON) Data Interchange Format&quot;">RFC8259</a>]), while output data (as defined by ES6),
   has a fixed representation.  As can be seen by the example, numbers
   are subject to rounding as well.

   The following subsections describe serialization of primitive JSON
   data types according to JCS.  This part is identical to that of ES6.

<span class="h5"><a class="selflink" name="section-3.2.2.1" href="#section-3.2.2.1">3.2.2.1</a>.  Serialization of Literals</span>

   The JSON literals "null", "true", and "false" present no challenge
   since they already have a fixed definition in JSON [<a href="http://tools.ietf.org/html//rfc8259" title="&quot;The JavaScript Object Notation (JSON) Data Interchange Format&quot;">RFC8259</a>].



<span class="grey">Rundgren, et al.          Expires 16 March 2020                 [Page 5]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-6" id="page-6" href="#page-6" class="invisible"> </a>
<span class="grey">Internet-Draft <a href="http://tools.ietf.org/html//draft-rundgren-json-canonicalization-schemeSeptember">draft-rundgren-json-canonicalization-schemeSeptember</a> 2019</span>


<span class="h5"><a class="selflink" name="section-3.2.2.2" href="#section-3.2.2.2">3.2.2.2</a>.  Serialization of Strings</span>

   For JSON String data (which includes JSON Object property names as
   well), each Unicode code point MUST be serialized as described below
   (also matching Section 24.3.2.2 of [<a href="#ref-ES6" title="&quot;ECMAScript 2015 Language Specification&quot;">ES6</a>]):

   •  If the Unicode value falls within the traditional ASCII control
      character range (U+0000 through U+001F), it MUST be serialized
      using lowercase hexadecimal Unicode notation (\uhhhh) unless it is
      in the set of predefined JSON control characters U+0008, U+0009,
      U+000A, U+000C or U+000D which MUST be serialized as \b, \t, \n,
      \f and \r respectively.

   •  If the Unicode value is outside of the ASCII control character
      range, it MUST be serialized "as is" unless it is equivalent to
      U+005C (\) or U+0022 (") which MUST be serialized as \\ and \"
      respectively.

   Finally, the resulting sequence of Unicode code points MUST be
   enclosed in double quotes (").

   Note: some JSON systems permit the use of invalid Unicode data
   including "lone surrogates" (e.g.  U+DEAD).  Since this leads to
   interoperability issues including broken signatures, occurrences of
   such data MUST cause the JCS algorithm to terminate with an error
   indication.

<span class="h5"><a class="selflink" name="section-3.2.2.3" href="#section-3.2.2.3">3.2.2.3</a>.  Serialization of Numbers</span>

   JSON Number data MUST be serialized according to Section 7.1.12.1 of
   [<a href="#ref-ES6" title="&quot;ECMAScript 2015 Language Specification&quot;">ES6</a>] including the "Note 2" enhancement.

   Due to the relative complexity of this part, the algorithm itself is
   not included in this document.  However, the specification is fully
   implemented by for example Google's V8 [<a href="#ref-V8" title="&quot;Chrome V8 Open Source JavaScript Engine&quot;">V8</a>].  The open source Java
   implementation mentioned in <a href="#appendix-G">Appendix G</a> uses a recently developed
   number serialization algorithm called Ryu [<a href="#ref-RYU" title="&quot;Ryu floating point number serializing algorithm&quot;">RYU</a>].

   ES6 builds on the IEEE-754 [<a href="#ref-IEEE754" title="&quot;IEEE Standard for Floating-Point Arithmetic&quot;">IEEE754</a>] double precision standard for
   representing JSON Number data.  <a href="#appendix-B">Appendix B</a> holds a set of IEEE-754
   sample values and their corresponding JSON serialization.

   Note: since NaN (Not a Number) and Infinity are not permitted in
   JSON, occurrences of such values MUST cause the JCS algorithm to
   terminate with an error indication.






<span class="grey">Rundgren, et al.          Expires 16 March 2020                 [Page 6]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-7" id="page-7" href="#page-7" class="invisible"> </a>
<span class="grey">Internet-Draft <a href="http://tools.ietf.org/html//draft-rundgren-json-canonicalization-schemeSeptember">draft-rundgren-json-canonicalization-schemeSeptember</a> 2019</span>


<span class="h4"><a class="selflink" name="section-3.2.3" href="#section-3.2.3">3.2.3</a>.  Sorting of Object Properties</span>

   Although the previous step indeed normalized the representation of
   primitive JSON data types, the result would not qualify as
   "canonical" since JSON Object properties are not in lexicographic
   (alphabetical) order.

   Applied to the sample in <a href="#section-3.2.2">Section 3.2.2</a>, a properly canonicalized
   version should (with a line wrap added for display purposes only),
   read as:

     {"literals":[null,true,false],"numbers":[333333333.3333333,
     1e+30,4.5,0.002,1e-27],"string":"€$\u000f\nA'B\"\\\\\"/"}

   The rules for lexicographic sorting of JSON Object properties
   according to JCS are as follows:

   •  JSON Object properties MUST be sorted in a recursive manner which
      means that possible JSON child Objects MUST have their properties
      sorted as well.

   •  JSON Array data MUST also be scanned for presence of JSON Objects
      (and applying associated property sorting), but array element
      order MUST NOT be changed.

   When a JSON Object is about to have its properties sorted, the
   following measures MUST be adhered to:

   •  The sorting process is applied to property name strings in their
      "raw" (unescaped) form.  That is, a newline character is treated
      as U+000A.

   •  Property name strings to be sorted are formatted as arrays of
      UTF-16 [<a href="#ref-UNICODE" title="&quot;The Unicode Standard, Version 12.1.0&quot;">UNICODE</a>] code units.  The sorting is based on pure value
      comparisons, where code units are treated as unsigned integers,
      independent of locale settings.

   •  Property name strings either have different values at some index
      that is a valid index for both strings, or their lengths are
      different, or both.  If they have different values at one or more
      index positions, let k be the smallest such index; then the string
      whose value at position k has the smaller value, as determined by
      using the &lt; operator, lexicographically precedes the other string.
      If there is no index position at which they differ, then the
      shorter string lexicographically precedes the longer string.

      In plain English this means that property names are sorted in
      ascending order like the following:



<span class="grey">Rundgren, et al.          Expires 16 March 2020                 [Page 7]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-8" id="page-8" href="#page-8" class="invisible"> </a>
<span class="grey">Internet-Draft <a href="http://tools.ietf.org/html//draft-rundgren-json-canonicalization-schemeSeptember">draft-rundgren-json-canonicalization-schemeSeptember</a> 2019</span>


           ""
           "a"
           "aa"
           "ab"

   The rationale for basing the sorting algorithm on UTF-16 code units
   is that it maps directly to the string type in ECMAScript (featured
   in Web browsers and Node.js), Java and .NET.  In addition, JSON only
   supports escape sequences expressed as UTF-16 code units making
   knowledge and handling of such data a necessity anyway.  Systems
   using another internal representation of string data will need to
   convert JSON property name strings into arrays of UTF-16 code units
   before sorting.  The conversion from UTF-8 or UTF-32 to UTF-16 is
   defined by the Unicode [<a href="#ref-UNICODE" title="&quot;The Unicode Standard, Version 12.1.0&quot;">UNICODE</a>] standard.

   The following test data can be used for verifying the correctness of
   the sorting scheme in a JCS implementation.  Input JSON data:

     {
       "\u20ac": "Euro Sign",
       "\r": "Carriage Return",
       "\ufb33": "Hebrew Letter Dalet With Dagesh",
       "1": "One",
       "\ud83d\ude00": "Emoji: Grinning Face",
       "\u0080": "Control",
       "\u00f6": "Latin Small Letter O With Diaeresis"
     }

   Expected argument order after sorting property strings:

     "Carriage Return"
     "One"
     "Control"
     "Latin Small Letter O With Diaeresis"
     "Euro Sign"
     "Emoji: Grinning Face"
     "Hebrew Letter Dalet With Dagesh"

   Note: for the purpose of obtaining a deterministic property order
   sorting on UTF-8 or UTF-32 encoded data would also work but the
   outcome for JSON data like above would differ and thus be
   incompatible with this specification.  However, in practice property
   names are rarely defined outside of 7-bit ASCII making it possible
   sorting on string data in UTF-8 or UTF-32 without conversions and
   still be compatible with JCS.  If this is a viable option or not
   depends on the environment JCS is supposed to be used in.





<span class="grey">Rundgren, et al.          Expires 16 March 2020                 [Page 8]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-9" id="page-9" href="#page-9" class="invisible"> </a>
<span class="grey">Internet-Draft <a href="http://tools.ietf.org/html//draft-rundgren-json-canonicalization-schemeSeptember">draft-rundgren-json-canonicalization-schemeSeptember</a> 2019</span>


<span class="h4"><a class="selflink" name="section-3.2.4" href="#section-3.2.4">3.2.4</a>.  UTF-8 Generation</span>

   Finally, in order to create a platform independent representation,
   the result of the preceding step MUST be encoded in UTF-8.

   Applied to the sample in <a href="#section-3.2.3">Section 3.2.3</a> this should yield the
   following bytes here shown in hexadecimal notation:

     7b 22 6c 69 74 65 72 61 6c 73 22 3a 5b 6e 75 6c 6c 2c 74 72
     75 65 2c 66 61 6c 73 65 5d 2c 22 6e 75 6d 62 65 72 73 22 3a
     5b 33 33 33 33 33 33 33 33 33 2e 33 33 33 33 33 33 33 2c 31
     65 2b 33 30 2c 34 2e 35 2c 30 2e 30 30 32 2c 31 65 2d 32 37
     5d 2c 22 73 74 72 69 6e 67 22 3a 22 e2 82 ac 24 5c 75 30 30
     30 66 5c 6e 41 27 42 5c 22 5c 5c 5c 5c 5c 22 2f 22 7d

   This data is intended to be usable as input to cryptographic methods.

<span class="h2"><a class="selflink" name="section-4" href="#section-4">4</a>.  IANA Considerations</span>

   This document has no IANA actions.

<span class="h2"><a class="selflink" name="section-5" href="#section-5">5</a>.  Security Considerations</span>

   It is vital performing "sanity" checks on input data to avoid
   overflowing buffers and similar things that could affect the
   integrity of the system.

   When JCS is applied to signature schemes like the one described in
   <a href="#appendix-F">Appendix F</a>, applications MUST perform the following operations before
   acting upon received data:

   1.  Parse the JSON data and verify that it adheres to I-JSON.

   2.  Verify the data for correctness according to the conventions
       defined by the ecosystem where it is to be used.  This also
       includes locating the property holding the signature data.

   3.  Verify the signature.

   If any of these steps fail, the operation in progress MUST be
   aborted.

<span class="h2"><a class="selflink" name="section-6" href="#section-6">6</a>.  Acknowledgements</span>

   Building on ES6 Number serialization was originally proposed by
   James Manger.  This ultimately led to the adoption of the entire ES6
   serialization scheme for JSON primitives.




<span class="grey">Rundgren, et al.          Expires 16 March 2020                 [Page 9]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-10" id="page-10" href="#page-10" class="invisible"> </a>
<span class="grey">Internet-Draft <a href="http://tools.ietf.org/html//draft-rundgren-json-canonicalization-schemeSeptember">draft-rundgren-json-canonicalization-schemeSeptember</a> 2019</span>


   Other people who have contributed with valuable input to this
   specification include Scott Ananian, Tim Bray, Ben Campbell, Adrian
   Farell, Richard Gibson, Bron Gondwana, John-Mark Gurney, John Levine,
   Mark Miller, Matt Miller, Mike Jones, Mark Nottingham, Mike Samuel,
   Jim Schaad, Robert Tupelo-Schneck and Michal Wadas.

   For carrying out real world concept verification, the software and
   support for number serialization provided by Ulf Adams,
   Tanner Gooding and Remy Oudompheng was very helpful.

<span class="h2"><a class="selflink" name="section-7" href="#section-7">7</a>.  References</span>

<span class="h3"><a class="selflink" name="section-7.1" href="#section-7.1">7.1</a>.  Normative References</span>

   [<a name="ref-ES6" id="ref-ES6">ES6</a>]      Ecma International, "ECMAScript 2015 Language
              Specification", June 2015,
              &lt;<a href="https://www.ecma-international.org/ecma-262/6.0/index.html">https://www.ecma-international.org/ecma-262/6.0/</a>
              <a href="https://www.ecma-international.org/ecma-262/6.0/index.html">index.html</a>&gt;.

   [<a name="ref-IEEE754" id="ref-IEEE754">IEEE754</a>]  IEEE, "IEEE Standard for Floating-Point Arithmetic",
              August 2008, &lt;<a href="http://grouper.ieee.org/groups/754/">http://grouper.ieee.org/groups/754/</a>&gt;.

   [<a name="ref-RFC2119" id="ref-RFC2119">RFC2119</a>]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", <a href="http://tools.ietf.org/html//bcp14">BCP 14</a>, <a href="http://tools.ietf.org/html//rfc2119">RFC 2119</a>,
              DOI 10.17487/RFC2119, March 1997,
              &lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;.

   [<a name="ref-RFC7493" id="ref-RFC7493">RFC7493</a>]  Bray, T., Ed., "The I-JSON Message Format", <a href="http://tools.ietf.org/html//rfc7493">RFC 7493</a>,
              DOI 10.17487/RFC7493, March 2015,
              &lt;<a href="https://www.rfc-editor.org/info/rfc7493">https://www.rfc-editor.org/info/rfc7493</a>&gt;.

   [<a name="ref-RFC8174" id="ref-RFC8174">RFC8174</a>]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in <a href="http://tools.ietf.org/html//rfc2119">RFC</a>
              <a href="http://tools.ietf.org/html//rfc2119">2119</a> Key Words", <a href="http://tools.ietf.org/html//bcp14">BCP 14</a>, <a href="http://tools.ietf.org/html//rfc8174">RFC 8174</a>, DOI 10.17487/RFC8174,
              May 2017, &lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;.

   [<a name="ref-RFC8259" id="ref-RFC8259">RFC8259</a>]  Bray, T., Ed., "The JavaScript Object Notation (JSON) Data
              Interchange Format", STD 90, <a href="http://tools.ietf.org/html//rfc8259">RFC 8259</a>,
              DOI 10.17487/RFC8259, December 2017,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8259">https://www.rfc-editor.org/info/rfc8259</a>&gt;.

   [<a name="ref-UNICODE" id="ref-UNICODE">UNICODE</a>]  The Unicode Consortium, "The Unicode Standard, Version
              12.1.0", May 2019,
              &lt;<a href="https://www.unicode.org/versions/Unicode12.1.0/">https://www.unicode.org/versions/Unicode12.1.0/</a>&gt;.

<span class="h3"><a class="selflink" name="section-7.2" href="#section-7.2">7.2</a>.  Informal References</span>

   [<a name="ref-JSONCOMP" id="ref-JSONCOMP">JSONCOMP</a>] A. Rundgren, ""Comparable" JSON - Work in progress",




<span class="grey">Rundgren, et al.          Expires 16 March 2020                [Page 10]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-11" id="page-11" href="#page-11" class="invisible"> </a>
<span class="grey">Internet-Draft <a href="http://tools.ietf.org/html//draft-rundgren-json-canonicalization-schemeSeptember">draft-rundgren-json-canonicalization-schemeSeptember</a> 2019</span>


              &lt;<a href="https://tools.ietf.org/html/draft-rundgren-comparable-json-04">https://tools.ietf.org/html/draft-rundgren-comparable-</a>
              <a href="https://tools.ietf.org/html/draft-rundgren-comparable-json-04">json-04</a>&gt;.

   [<a name="ref-KEYBASE" id="ref-KEYBASE">KEYBASE</a>]  "Keybase",
              &lt;<a href="https://keybase.io/docs/api/1.0/canonical_packings#json">https://keybase.io/docs/api/1.0/canonical_packings#json</a>&gt;.

   [<a name="ref-NODEJS" id="ref-NODEJS">NODEJS</a>]   "Node.js", &lt;<a href="https://nodejs.org">https://nodejs.org</a>&gt;.

   [<a name="ref-OPENAPI" id="ref-OPENAPI">OPENAPI</a>]  "The OpenAPI Initiative", &lt;<a href="https://www.openapis.org/">https://www.openapis.org/</a>&gt;.

   [<a name="ref-RFC4648" id="ref-RFC4648">RFC4648</a>]  Josefsson, S., "The Base16, Base32, and Base64 Data
              Encodings", <a href="http://tools.ietf.org/html//rfc4648">RFC 4648</a>, DOI 10.17487/RFC4648, October 2006,
              &lt;<a href="https://www.rfc-editor.org/info/rfc4648">https://www.rfc-editor.org/info/rfc4648</a>&gt;.

   [<a name="ref-RFC7515" id="ref-RFC7515">RFC7515</a>]  Jones, M., Bradley, J., and N. Sakimura, "JSON Web
              Signature (JWS)", <a href="http://tools.ietf.org/html//rfc7515">RFC 7515</a>, DOI 10.17487/RFC7515, May
              2015, &lt;<a href="https://www.rfc-editor.org/info/rfc7515">https://www.rfc-editor.org/info/rfc7515</a>&gt;.

   [<a name="ref-RFC7638" id="ref-RFC7638">RFC7638</a>]  Jones, M. and N. Sakimura, "JSON Web Key (JWK)
              Thumbprint", <a href="http://tools.ietf.org/html//rfc7638">RFC 7638</a>, DOI 10.17487/RFC7638, September
              2015, &lt;<a href="https://www.rfc-editor.org/info/rfc7638">https://www.rfc-editor.org/info/rfc7638</a>&gt;.

   [<a name="ref-RYU" id="ref-RYU">RYU</a>]      Ulf Adams, "Ryu floating point number serializing
              algorithm", &lt;<a href="https://github.com/ulfjack/ryu">https://github.com/ulfjack/ryu</a>&gt;.

   [<a name="ref-V8" id="ref-V8">V8</a>]       Google LLC, "Chrome V8 Open Source JavaScript Engine",
              &lt;<a href="https://developers.google.com/v8/">https://developers.google.com/v8/</a>&gt;.

   [<a name="ref-XMLDSIG" id="ref-XMLDSIG">XMLDSIG</a>]  W3C, "XML Signature Syntax and Processing Version 1.1",
              &lt;<a href="https://www.w3.org/TR/xmldsig-core1/">https://www.w3.org/TR/xmldsig-core1/</a>&gt;.

<span class="h2"><a class="selflink" name="appendix-A" href="#appendix-A">Appendix A</a>.  ES6 Sample Canonicalizer</span>

   Below is an example of a JCS canonicalizer for usage with ES6 based
   systems:

     ////////////////////////////////////////////////////////////
     // Since the primary purpose of this code is highlighting //
     // the core of the JCS algorithm, error handling and      //
     // UTF-8 generation were not implemented                  //
     ////////////////////////////////////////////////////////////
     var canonicalize = function(object) {

         var buffer = '';
         serialize(object);
         return buffer;

         function serialize(object) {



<span class="grey">Rundgren, et al.          Expires 16 March 2020                [Page 11]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-12" id="page-12" href="#page-12" class="invisible"> </a>
<span class="grey">Internet-Draft <a href="http://tools.ietf.org/html//draft-rundgren-json-canonicalization-schemeSeptember">draft-rundgren-json-canonicalization-schemeSeptember</a> 2019</span>


             if (object === null || typeof object !== 'object' ||
                 object.toJSON != null) {
                 /////////////////////////////////////////////////
                 // Primitive type or toJSON - Use ES6/JSON     //
                 /////////////////////////////////////////////////
                 buffer += JSON.stringify(object);

             } else if (Array.isArray(object)) {
                 /////////////////////////////////////////////////
                 // Array - Maintain element order              //
                 /////////////////////////////////////////////////
                 buffer += '[';
                 let next = false;
                 object.forEach((element) =&gt; {
                     if (next) {
                         buffer += ',';
                     }
                     next = true;
                     /////////////////////////////////////////
                     // Array element - Recursive expansion //
                     /////////////////////////////////////////
                     serialize(element);
                 });
                 buffer += ']';

             } else {
                 /////////////////////////////////////////////////
                 // Object - Sort properties before serializing //
                 /////////////////////////////////////////////////
                 buffer += '{';
                 let next = false;
                 Object.keys(object).sort().forEach((property) =&gt; {
                     if (next) {
                         buffer += ',';
                     }
                     next = true;
                     ///////////////////////////////////////////////
                     // Property names are strings - Use ES6/JSON //
                     ///////////////////////////////////////////////
                     buffer += JSON.stringify(property);
                     buffer += ':';
                     //////////////////////////////////////////
                     // Property value - Recursive expansion //
                     //////////////////////////////////////////
                     serialize(object[property]);
                 });
                 buffer += '}';
             }



<span class="grey">Rundgren, et al.          Expires 16 March 2020                [Page 12]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-13" id="page-13" href="#page-13" class="invisible"> </a>
<span class="grey">Internet-Draft <a href="http://tools.ietf.org/html//draft-rundgren-json-canonicalization-schemeSeptember">draft-rundgren-json-canonicalization-schemeSeptember</a> 2019</span>


         }
     };

<span class="h2"><a class="selflink" name="appendix-B" href="#appendix-B">Appendix B</a>.  Number Serialization Samples</span>

   The following table holds a set of ES6 compatible Number
   serialization samples, including some edge cases.  The column
   "IEEE-754" refers to the internal ES6 representation of the Number
   data type which is based on the IEEE-754 [<a href="#ref-IEEE754" title="&quot;IEEE Standard for Floating-Point Arithmetic&quot;">IEEE754</a>] standard using
   64-bit (double precision) values, here expressed in hexadecimal.

 ╒══════════════════╤═══════════════════════════╤═════════════════════╕
 │     IEEE-754     │    JSON Representation    │       Comment       │
 ╞══════════════════╪═══════════════════════════╪═════════════════════╡
 │ 0000000000000000 │ 0                         │ Zero                │
 ├──────────────────┼───────────────────────────┼─────────────────────┤
 │ 8000000000000000 │ 0                         │ Minus zero          │
 ├──────────────────┼───────────────────────────┼─────────────────────┤
 │ 0000000000000001 │ 5e-324                    │ Min pos number      │
 ├──────────────────┼───────────────────────────┼─────────────────────┤
 │ 8000000000000001 │ -5e-324                   │ Min neg number      │
 ├──────────────────┼───────────────────────────┼─────────────────────┤
 │ 7fefffffffffffff │ 1.7976931348623157e+308   │ Max pos number      │
 ├──────────────────┼───────────────────────────┼─────────────────────┤
 │ ffefffffffffffff │ -1.7976931348623157e+308  │ Max neg number      │
 ├──────────────────┼───────────────────────────┼─────────────────────┤
 │ 4340000000000000 │ 9007199254740992          │ Max pos integer (1) │
 ├──────────────────┼───────────────────────────┼─────────────────────┤
 │ c340000000000000 │ -9007199254740992         │ Max neg integer (1) │
 ├──────────────────┼───────────────────────────┼─────────────────────┤
 │ 4430000000000000 │ 295147905179352830000     │ ~2**68 (2)          │
 ├──────────────────┼───────────────────────────┼─────────────────────┤
 │ 7fffffffffffffff │                           │ NaN (3)             │
 ├──────────────────┼───────────────────────────┼─────────────────────┤
 │ 7ff0000000000000 │                           │ Infinity (3)        │
 ├──────────────────┼───────────────────────────┼─────────────────────┤
 │ 44b52d02c7e14af5 │ 9.999999999999997e+22     │                     │
 ├──────────────────┼───────────────────────────┼─────────────────────┤
 │ 44b52d02c7e14af6 │ 1e+23                     │                     │
 ├──────────────────┼───────────────────────────┼─────────────────────┤
 │ 44b52d02c7e14af7 │ 1.0000000000000001e+23    │                     │
 ├──────────────────┼───────────────────────────┼─────────────────────┤
 │ 444b1ae4d6e2ef4e │ 999999999999999700000     │                     │
 ├──────────────────┼───────────────────────────┼─────────────────────┤
 │ 444b1ae4d6e2ef4f │ 999999999999999900000     │                     │
 ├──────────────────┼───────────────────────────┼─────────────────────┤
 │ 444b1ae4d6e2ef50 │ 1e+21                     │                     │
 ├──────────────────┼───────────────────────────┼─────────────────────┤



<span class="grey">Rundgren, et al.          Expires 16 March 2020                [Page 13]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-14" id="page-14" href="#page-14" class="invisible"> </a>
<span class="grey">Internet-Draft <a href="http://tools.ietf.org/html//draft-rundgren-json-canonicalization-schemeSeptember">draft-rundgren-json-canonicalization-schemeSeptember</a> 2019</span>


 │ 3eb0c6f7a0b5ed8c │ 9.999999999999997e-7      │                     │
 ├──────────────────┼───────────────────────────┼─────────────────────┤
 │ 3eb0c6f7a0b5ed8d │ 0.000001                  │                     │
 ├──────────────────┼───────────────────────────┼─────────────────────┤
 │ 41b3de4355555553 │ 333333333.3333332         │                     │
 ├──────────────────┼───────────────────────────┼─────────────────────┤
 │ 41b3de4355555554 │ 333333333.33333325        │                     │
 ├──────────────────┼───────────────────────────┼─────────────────────┤
 │ 41b3de4355555555 │ 333333333.3333333         │                     │
 ├──────────────────┼───────────────────────────┼─────────────────────┤
 │ 41b3de4355555556 │ 333333333.3333334         │                     │
 ├──────────────────┼───────────────────────────┼─────────────────────┤
 │ 41b3de4355555557 │ 333333333.33333343        │                     │
 ├──────────────────┼───────────────────────────┼─────────────────────┤
 │ becbf647612f3696 │ -0.0000033333333333333333 │                     │
 ├──────────────────┼───────────────────────────┼─────────────────────┤
 │ 43143ff3c1cb0959 │ 1424953923781206.2        │ Round to even (4)   │
 └──────────────────┴───────────────────────────┴─────────────────────┘

   Notes:

   (1)  For maximum compliance with the ES6 "JSON" object values that
        are to be interpreted as true integers SHOULD be in the range
        -9007199254740991 to 9007199254740991.  However, how numbers are
        used in applications do not affect the JCS algorithm.

   (2)  Although a set of specific integers like 2**68 could be regarded
        as having extended precision, the JCS/ES6 number serialization
        algorithm does not take this in consideration.

   (3)  Invalid.  See <a href="#section-3.2.2.3">Section 3.2.2.3</a>.

   (4)  This number is exactly 1424953923781206.25 but will after the
        "Note 2" rule mentioned in <a href="#section-3.2.2.3">Section 3.2.2.3</a> be truncated and
        rounded to the closest even value.

<span class="h2"><a class="selflink" name="appendix-C" href="#appendix-C">Appendix C</a>.  Canonicalized JSON as "Wire Format"</span>

   Since the result from the canonicalization process (see
   <a href="#section-3.2.4">Section 3.2.4</a>), is fully valid JSON, it can also be used as
   "Wire Format".  However, this is just an option since cryptographic
   schemes based on JCS, in most cases would not depend on that
   externally supplied JSON data already is canonicalized.

   In fact, the ES6 standard way of serializing objects using
   "JSON.stringify()" produces a more "logical" format, where properties
   are kept in the order they were created or received.  The example




<span class="grey">Rundgren, et al.          Expires 16 March 2020                [Page 14]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-15" id="page-15" href="#page-15" class="invisible"> </a>
<span class="grey">Internet-Draft <a href="http://tools.ietf.org/html//draft-rundgren-json-canonicalization-schemeSeptember">draft-rundgren-json-canonicalization-schemeSeptember</a> 2019</span>


   below shows an address record which could benefit from ES6 standard
   serialization:

     {
       "name": "John Doe",
       "address": "2000 Sunset Boulevard",
       "city": "Los Angeles",
       "zip": "90001",
       "state": "CA"
     }

   Using canonicalization the properties above would be output in the
   order "address", "city", "name", "state" and "zip", which adds
   fuzziness to the data from a human (developer or technical support),
   perspective.  Canonicalization also converts JSON data into a single
   line of text, which may be less than ideal for debugging and logging.

<span class="h2"><a class="selflink" name="appendix-D" href="#appendix-D">Appendix D</a>.  Dealing with Big Numbers</span>

   There are several issues associated with the JSON Number type, here
   illustrated by the following sample object:

     {
       "giantNumber": 1.4e+9999,
       "payMeThis": 26000.33,
       "int64Max": 9223372036854775807
     }

   Although the sample above conforms to JSON [<a href="http://tools.ietf.org/html//rfc8259" title="&quot;The JavaScript Object Notation (JSON) Data Interchange Format&quot;">RFC8259</a>], applications
   would normally use different native data types for storing
   "giantNumber" and "int64Max".  In addition, monetary data like
   "payMeThis" would presumably not rely on floating point data types
   due to rounding issues with respect to decimal arithmetic.

   The established way handling this kind of "overloading" of the JSON
   Number type (at least in an extensible manner), is through mapping
   mechanisms, instructing parsers what to do with different properties
   based on their name.  However, this greatly limits the value of using
   the JSON Number type outside of its original somewhat constrained,
   JavaScript context.  The ES6 "JSON" object does not support mappings
   to JSON Number either.

   Due to the above, numbers that do not have a natural place in the
   current JSON ecosystem MUST be wrapped using the JSON String type.
   This is close to a de-facto standard for open systems.  This is also
   applicable for other data types that do not have direct support in
   JSON, like "DateTime" objects as described in <a href="#appendix-E">Appendix E</a>.




<span class="grey">Rundgren, et al.          Expires 16 March 2020                [Page 15]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-16" id="page-16" href="#page-16" class="invisible"> </a>
<span class="grey">Internet-Draft <a href="http://tools.ietf.org/html//draft-rundgren-json-canonicalization-schemeSeptember">draft-rundgren-json-canonicalization-schemeSeptember</a> 2019</span>


   Aided by a system using the JSON String type; be it programmatic like

     var obj = JSON.parse('{"giantNumber": "1.4e+9999"}');
     var biggie = new BigNumber(obj.giantNumber);

   or declarative schemes like OpenAPI [<a href="#ref-OPENAPI" title="&quot;The OpenAPI Initiative&quot;">OPENAPI</a>], JCS imposes no limits
   on applications, including when using ES6.

<span class="h2"><a class="selflink" name="appendix-E" href="#appendix-E">Appendix E</a>.  String Subtype Handling</span>

   Due to the limited set of data types featured in JSON, the JSON
   String type is commonly used for holding subtypes.  This can
   depending on JSON parsing method lead to interoperability problems
   which MUST be dealt with by JCS compliant applications targeting a
   wider audience.

   Assume you want to parse a JSON object where the schema designer
   assigned the property "big" for holding a "BigInteger" subtype and
   "time" for holding a "DateTime" subtype, while "val" is supposed to
   be a JSON Number compliant with JCS.  The following example shows
   such an object:

     {
       "time": "2019-01-28T07:45:10Z",
       "big": "055",
       "val": 3.5
     }

   Parsing of this object can accomplished by the following ES6
   statement:

     var object = JSON.parse(JSON_object_featured_as_a_string);

   After parsing the actual data can be extracted which for subtypes
   also involve a conversion step using the result of the parsing
   process (an ECMAScript object) as input:

     ... = new Date(object.time); // Date object
     ... = BigInt(object.big);    // Big integer
     ... = object.val;            // JSON/JS number

   Canonicalization of "object" using the sample code in <a href="#appendix-A">Appendix A</a>
   would return the following string:

     {"big":"055","time":"2019-01-28T07:45:10Z",val:3.5}

   Although this is (with respect to JCS) technically correct, there is




<span class="grey">Rundgren, et al.          Expires 16 March 2020                [Page 16]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-17" id="page-17" href="#page-17" class="invisible"> </a>
<span class="grey">Internet-Draft <a href="http://tools.ietf.org/html//draft-rundgren-json-canonicalization-schemeSeptember">draft-rundgren-json-canonicalization-schemeSeptember</a> 2019</span>


   another way parsing JSON data which also can be used with ECMAScript
   as shown below:

     // Note: "BigInt" is implemented by Google's V8 ECMAScript engine.
     // It requires the following code to become JSON serializable.
     BigInt.prototype.toJSON = function() {
         return this.toString();
     };

     // JSON parsing using a "stream" based method
     var object = JSON.parse(JSON_object_featured_as_a_string,
         (k,v) =&gt; k == 'time' ? new Date(v) : k == 'big' ? BigInt(v) : v
     );

   If you now apply the canonicalizer in <a href="#appendix-A">Appendix A</a> to "object", the
   following string would be generated:

     {"big":"55","time":"2019-01-28T07:45:10.000Z","val":3.5}

   In this case the string arguments for "big" and "time" have changed
   with respect to the original, presumable making an application
   depending on JCS fail.

   The reason for the deviation is that in stream and schema based JSON
   parsers, the original "string" argument is typically replaced on-the-
   fly by the native subtype which when serialized, may exhibit a
   different and platform dependent pattern.

   That is, stream and schema based parsing MUST treat subtypes as
   "pure" (immutable) JSON String types, and perform the actual
   conversion to the designated native type in a subsequent step.  In
   modern programming platforms like Go, Java and C# this can be
   achieved with moderate efforts by combining annotations, getters and
   setters.  Below is an example in C#/Json.NET showing a part of a
   class that is serializable as a JSON Object:

     // The "pure" string solution uses a local
     // string variable for JSON serialization while
     // exposing another type to the application
     [JsonProperty("amount")]
     private string _amount;

     [<a name="ref-JsonIgnore" id="ref-JsonIgnore">JsonIgnore</a>]
     public decimal Amount {
         get { return decimal.Parse(_amount); }
         set { _amount = value.ToString(); }
     }




<span class="grey">Rundgren, et al.          Expires 16 March 2020                [Page 17]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-18" id="page-18" href="#page-18" class="invisible"> </a>
<span class="grey">Internet-Draft <a href="http://tools.ietf.org/html//draft-rundgren-json-canonicalization-schemeSeptember">draft-rundgren-json-canonicalization-schemeSeptember</a> 2019</span>


   In an application "Amount" can be accessed as any other property
   while it is actually represented by a quoted string in JSON contexts.

   Note: the example above also addresses the constraints on numeric
   data implied by I-JSON (the C# "decimal" data type has quite
   different characteristics compared to IEEE-754 double precision).

<span class="h3"><a class="selflink" name="appendix-E.1" href="#appendix-E.1">E.1</a>.  Subtypes in Arrays</span>

   Since the JSON Array construct permits mixing arbitrary JSON data
   types, custom parsing and serialization code may be required to cope
   with subtypes anyway.

<span class="h2"><a class="selflink" name="appendix-F" href="#appendix-F">Appendix F</a>.  Implementation Guidelines</span>

   The optimal solution is integrating support for JCS directly in JSON
   serializers (parsers need no changes).  That is, canonicalization
   would just be an additional "mode" for a JSON serializer.  However,
   this is currently not the case.  Fortunately JCS support can be
   performed through externally supplied canonicalizer software,
   enabling signature creation schemes like the following:

   1.  Create the data to be signed.

   2.  Serialize the data using existing JSON tools.

   3.  Let the external canonicalizer process the serialized data and
       return canonicalized result data.

   4.  Sign the canonicalized data.

   5.  Add the resulting signature value to the original JSON data
       through a designated signature property.

   6.  Serialize the completed (now signed) JSON object using existing
       JSON tools.

   A compatible signature verification scheme would then be as follows:

   1.  Parse the signed JSON data using existing JSON tools.

   2.  Read and save the signature value from the designated signature
       property.

   3.  Remove the signature property from the parsed JSON object.

   4.  Serialize the remaining JSON data using existing JSON tools.




<span class="grey">Rundgren, et al.          Expires 16 March 2020                [Page 18]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-19" id="page-19" href="#page-19" class="invisible"> </a>
<span class="grey">Internet-Draft <a href="http://tools.ietf.org/html//draft-rundgren-json-canonicalization-schemeSeptember">draft-rundgren-json-canonicalization-schemeSeptember</a> 2019</span>


   5.  Let the external canonicalizer process the serialized data and
       return canonicalized result data.

   6.  Verify that the canonicalized data matches the saved signature
       value using the algorithm and key used for creating the
       signature.

   A canonicalizer like above is effectively only a "filter",
   potentially usable with a multitude of quite different cryptographic
   schemes.

   Using a JSON serializer with integrated JCS support, the
   serialization performed before the canonicalization step could be
   eliminated for both processes.

<span class="h2"><a class="selflink" name="appendix-G" href="#appendix-G">Appendix G</a>.  Open Source Implementations</span>

   The following Open Source implementations have been verified to be
   compatible with JCS:

   •  JavaScript: <a href="https://www.npmjs.com/package/canonicalize">https://www.npmjs.com/package/canonicalize</a>

   •  Java: <a href="https://github.com/erdtman/java-json-canonicalization">https://github.com/erdtman/java-json-canonicalization</a>

   •  Go: <a href="https://github.com/cyberphone/json-canonicalization/tree/master/go">https://github.com/cyberphone/json-</a>
      <a href="https://github.com/cyberphone/json-canonicalization/tree/master/go">canonicalization/tree/master/go</a>

   •  .NET/C#: <a href="https://github.com/cyberphone/json-canonicalization/tree/master/dotnet">https://github.com/cyberphone/json-</a>
      <a href="https://github.com/cyberphone/json-canonicalization/tree/master/dotnet">canonicalization/tree/master/dotnet</a>

   •  Python: <a href="https://github.com/cyberphone/json-canonicalization/tree/master/python3">https://github.com/cyberphone/json-</a>
      <a href="https://github.com/cyberphone/json-canonicalization/tree/master/python3">canonicalization/tree/master/python3</a>

<span class="h2"><a class="selflink" name="appendix-H" href="#appendix-H">Appendix H</a>.  Other JSON Canonicalization Efforts</span>

   There are (and have been) other efforts creating "Canonical JSON".
   Below is a list of URLs to some of them:

   •  <a href="https://tools.ietf.org/html/draft-staykov-hu-json-canonical-form-00">https://tools.ietf.org/html/draft-staykov-hu-json-canonical-</a>
      <a href="https://tools.ietf.org/html/draft-staykov-hu-json-canonical-form-00">form-00</a>

   •  <a href="https://gibson042.github.io/canonicaljson-spec/">https://gibson042.github.io/canonicaljson-spec/</a>

   •  <a href="http://wiki.laptop.org/go/Canonical_JSON">http://wiki.laptop.org/go/Canonical_JSON</a>

   The listed efforts all build on text level JSON to JSON
   transformations.  The primary feature of text level canonicalization
   is that it can be made neutral to the flavor of JSON used.  However,



<span class="grey">Rundgren, et al.          Expires 16 March 2020                [Page 19]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-20" id="page-20" href="#page-20" class="invisible"> </a>
<span class="grey">Internet-Draft <a href="http://tools.ietf.org/html//draft-rundgren-json-canonicalization-schemeSeptember">draft-rundgren-json-canonicalization-schemeSeptember</a> 2019</span>


   such schemes also imply major changes to the JSON parsing process
   which is a likely hurdle for adoption.  Albeit at the expense of
   certain JSON and application constraints, JCS was designed to be
   compatible with existing JSON tools.

<span class="h2"><a class="selflink" name="appendix-I" href="#appendix-I">Appendix I</a>.  Development Portal</span>

   The JCS specification is currently developed at:
   <a href="https://github.com/cyberphone/ietf-json-canon">https://github.com/cyberphone/ietf-json-canon</a>.

   The most recent "editors' copy" can be found at:
   <a href="https://cyberphone.github.io/ietf-json-canon">https://cyberphone.github.io/ietf-json-canon</a>.

   JCS source code and extensive test data is available at:
   <a href="https://github.com/cyberphone/json-canonicalization">https://github.com/cyberphone/json-canonicalization</a>

<span class="h2"><a class="selflink" name="appendix-J" href="#appendix-J">Appendix J</a>.  Document History</span>

   [[ to be removed by the RFC Editor before publication as an RFC ]]

   Version 00-06:

   •  See IETF diff listings.

   Version 07:

   •  Initial converson to XML RFC version 3.

   •  Changed intended status to "Informational".

   •  Added UTF-16 test data and explanations.

   Version 08:

   •  Updated Abstract.

   •  Added a "Note 2" number serialization sample.

   •  Updated Security Considerations.

   •  Tried to clear up the JSON input data section.

   •  Added a line about Unicode normalization.

   •  Added a line about serialiation of structured data.

   •  Added a missing fact about "BigInt" (V8 not ES6).




<span class="grey">Rundgren, et al.          Expires 16 March 2020                [Page 20]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-21" id="page-21" href="#page-21" class="invisible"> </a>
<span class="grey">Internet-Draft <a href="http://tools.ietf.org/html//draft-rundgren-json-canonicalization-schemeSeptember">draft-rundgren-json-canonicalization-schemeSeptember</a> 2019</span>


Authors' Addresses

   Anders Rundgren
   Independent
   Montpellier
   France

   Email: anders.rundgren.net@gmail.com
   URI:   <a href="https://www.linkedin.com/in/andersrundgren/">https://www.linkedin.com/in/andersrundgren/</a>


   Bret Jordan
   Symantec Corporation
   350 Ellis Street
   Mountain View, CA 94043
   United States of America

   Email: bret_jordan@symantec.com


   Samuel Erdtman
   Spotify AB
   Birger Jarlsgatan 61, 4tr
   SE-113 56 Stockholm
   Sweden

   Email: erdtman@spotify.com
























Rundgren, et al.          Expires 16 March 2020                [Page 21]

</pre><br />
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.129c, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>
</body>
</html>
